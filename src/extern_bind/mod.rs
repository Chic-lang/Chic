use crate::error::{Error, Result};
use std::fmt::Write as _;
use std::fs;
use std::path::PathBuf;

#[derive(Debug, Clone)]
pub struct ExternBindOptions {
    pub header: PathBuf,
    pub output: PathBuf,
    pub namespace: String,
    pub library: String,
    pub binding: String,
    pub convention: String,
    pub optional: bool,
}

pub fn generate_bindings(options: &ExternBindOptions) -> Result<()> {
    let header = fs::read_to_string(&options.header).map_err(|err| {
        Error::Io(std::io::Error::new(
            err.kind(),
            format!("failed to read header {}: {err}", options.header.display()),
        ))
    })?;
    let sanitized = sanitize_header(&header);
    let prototypes = parse_prototypes(&sanitized);
    if prototypes.is_empty() {
        return Err(Error::codegen(format!(
            "no function prototypes found in {}",
            options.header.display()
        )));
    }

    let mut output = String::new();
    writeln!(&mut output, "// <auto-generated by chic extern bind>").ok();
    writeln!(&mut output, "namespace {};", options.namespace).ok();
    writeln!(&mut output).ok();
    for prototype in prototypes {
        emit_binding(&mut output, options, &prototype);
        writeln!(&mut output).ok();
    }

    if let Some(parent) = options.output.parent()
        && !parent.as_os_str().is_empty()
    {
        fs::create_dir_all(parent)?;
    }
    fs::write(&options.output, output)?;
    Ok(())
}

fn emit_binding(buffer: &mut String, options: &ExternBindOptions, prototype: &Prototype) {
    writeln!(
        buffer,
        "@extern(\n    convention = \"{}\",\n    library = \"{}\",\n    alias = \"{}\",\n    binding = \"{}\"{}",
        options.convention,
        options.library,
        prototype.name,
        options.binding,
        if options.optional { ",\n    optional = true" } else { "" }
    )
    .ok();
    writeln!(buffer, ")").ok();
    let params = if prototype.params.is_empty() {
        String::new()
    } else {
        prototype
            .params
            .iter()
            .map(|param| format!("{} {}", param.ty, param.name))
            .collect::<Vec<_>>()
            .join(", ")
    };
    writeln!(
        buffer,
        "public static extern {} {}({});",
        prototype.return_type, prototype.sanitized_name, params
    )
    .ok();
}

fn sanitize_header(source: &str) -> String {
    let mut result = String::with_capacity(source.len());
    let mut chars = source.chars().peekable();
    while let Some(ch) = chars.next() {
        match ch {
            '/' => {
                if let Some(next) = chars.peek() {
                    if *next == '/' {
                        while let Some(other) = chars.next() {
                            if other == '\n' {
                                result.push('\n');
                                break;
                            }
                        }
                        continue;
                    }
                    if *next == '*' {
                        chars.next();
                        while let Some(other) = chars.next() {
                            if other == '*' && chars.peek().is_some_and(|peek| *peek == '/') {
                                chars.next();
                                break;
                            }
                        }
                        continue;
                    }
                }
                result.push(ch);
            }
            _ => result.push(ch),
        }
    }

    result
        .lines()
        .filter(|line| !line.trim_start().starts_with('#'))
        .collect::<Vec<_>>()
        .join("\n")
}

fn parse_prototypes(source: &str) -> Vec<Prototype> {
    source.split(';').filter_map(parse_prototype).collect()
}

fn parse_prototype(statement: &str) -> Option<Prototype> {
    let trimmed = statement.trim();
    if trimmed.is_empty() || trimmed.contains('{') || trimmed.contains('}') {
        return None;
    }
    let open = trimmed.find('(')?;
    let close = trimmed.rfind(')')?;
    if close <= open {
        return None;
    }
    let before = trimmed[..open].trim();
    let params = trimmed[open + 1..close].trim();
    let tokens = tokenize(before);
    if tokens.is_empty() {
        return None;
    }
    let (name, return_tokens) = split_name_and_return(&tokens)?;
    let return_type = map_type(&return_tokens)?;
    if params.contains('(') || params.contains("...") {
        return None;
    }
    let mut parsed_params = Vec::new();
    if !(params.is_empty() || params.eq_ignore_ascii_case("void")) {
        let parts = split_params(params);
        for (index, part) in parts.iter().enumerate() {
            if let Some(param) = parse_param(part, index) {
                parsed_params.push(param);
            } else {
                return None;
            }
        }
    }

    Some(Prototype::new(name, return_type, parsed_params))
}

fn split_params(params: &str) -> Vec<String> {
    let mut parts = Vec::new();
    let mut current = String::new();
    for ch in params.chars() {
        if ch == ',' {
            if !current.trim().is_empty() {
                parts.push(current.trim().to_string());
            }
            current.clear();
        } else {
            current.push(ch);
        }
    }
    if !current.trim().is_empty() {
        parts.push(current.trim().to_string());
    }
    parts
}

fn parse_param(raw: &str, index: usize) -> Option<Parameter> {
    let tokens = tokenize(raw);
    if tokens.is_empty() {
        return None;
    }
    let mut name_index = None;
    for (idx, token) in tokens.iter().enumerate().rev() {
        if is_identifier(token) {
            name_index = Some(idx);
            break;
        }
    }
    let mut type_tokens = tokens.clone();
    let name = if let Some(idx) = name_index {
        type_tokens.remove(idx)
    } else {
        format!("arg{index}")
    };
    let ty = map_type(&type_tokens)?;
    Some(Parameter {
        name: sanitize_identifier(&name),
        ty,
    })
}

fn split_name_and_return(tokens: &[String]) -> Option<(String, Vec<String>)> {
    let mut name_index = None;
    for (idx, token) in tokens.iter().enumerate().rev() {
        if is_identifier(token) {
            name_index = Some(idx);
            break;
        }
    }
    let idx = name_index?;
    let mut return_tokens = tokens.to_vec();
    let name = return_tokens.remove(idx);
    Some((name, return_tokens))
}

fn tokenize(statement: &str) -> Vec<String> {
    let mut normalized = String::with_capacity(statement.len());
    for ch in statement.chars() {
        match ch {
            '*' | ',' | '(' | ')' => {
                normalized.push(' ');
                normalized.push(ch);
                normalized.push(' ');
            }
            _ if ch.is_whitespace() => normalized.push(' '),
            _ => normalized.push(ch),
        }
    }
    normalized
        .split_whitespace()
        .map(|token| token.to_string())
        .collect()
}

fn is_identifier(token: &str) -> bool {
    let mut chars = token.chars();
    match chars.next() {
        Some(first) if first.is_ascii_alphabetic() || first == '_' => {
            chars.all(|ch| ch.is_ascii_alphanumeric() || ch == '_')
        }
        _ => false,
    }
}

fn map_type(tokens: &[String]) -> Option<String> {
    if tokens.is_empty() {
        return None;
    }
    let mut pointer_level = 0usize;
    let mut base_tokens = Vec::new();
    let mut is_const = false;
    for token in tokens {
        if token == "*" {
            pointer_level += 1;
        } else if token.eq_ignore_ascii_case("const") {
            is_const = true;
        } else {
            base_tokens.push(token.clone());
        }
    }
    if base_tokens.is_empty() {
        base_tokens.push("int".into());
    }
    let mut normalized = base_tokens.join(" ");
    normalized = normalized.trim().to_string();
    let lower = normalized.to_ascii_lowercase();
    let base = match lower.as_str() {
        "void" => "void".to_string(),
        "bool" | "_bool" => "bool".to_string(),
        "char" => "byte".to_string(),
        "signed char" => "sbyte".to_string(),
        "unsigned char" => "byte".to_string(),
        "short" => "short".to_string(),
        "unsigned short" => "ushort".to_string(),
        "int" | "signed int" => "int".to_string(),
        "unsigned" | "unsigned int" => "uint".to_string(),
        "long" | "signed long" | "long int" => "long".to_string(),
        "unsigned long" | "unsigned long int" => "ulong".to_string(),
        "long long" | "signed long long" => "long".to_string(),
        "unsigned long long" => "ulong".to_string(),
        "float" => "float".to_string(),
        "double" => "double".to_string(),
        "size_t" => "usize".to_string(),
        "ssize_t" => "isize".to_string(),
        "uintptr_t" => "usize".to_string(),
        "intptr_t" => "isize".to_string(),
        other => other
            .trim_start_matches("struct ")
            .trim_start_matches("enum ")
            .trim()
            .to_string(),
    };

    let mut ty = base;
    for level in 0..pointer_level {
        let qualifier = if level == 0 && is_const {
            "*const"
        } else {
            "*mut"
        };
        ty = format!("{qualifier} {ty}");
    }
    Some(ty)
}

#[derive(Debug)]
struct Prototype {
    name: String,
    sanitized_name: String,
    return_type: String,
    params: Vec<Parameter>,
}

impl Prototype {
    fn new(name: String, return_type: String, params: Vec<Parameter>) -> Self {
        let sanitized_name = sanitize_identifier(&name);
        Self {
            name,
            sanitized_name,
            return_type,
            params,
        }
    }
}

fn sanitize_identifier(name: &str) -> String {
    let mut chars = name.chars();
    let first = chars
        .next()
        .map(|ch| {
            if ch.is_ascii_alphabetic() || ch == '_' {
                ch
            } else {
                '_'
            }
        })
        .unwrap_or('_');
    let rest = chars
        .map(|ch| {
            if ch.is_ascii_alphanumeric() || ch == '_' {
                ch
            } else {
                '_'
            }
        })
        .collect::<String>();
    format!("{first}{rest}")
}

#[derive(Debug)]
struct Parameter {
    name: String,
    ty: String,
}

#[cfg(test)]
mod tests {
    use super::*;
    use tempfile::tempdir;

    #[test]
    fn generate_bindings_emits_metadata_and_namespace() {
        let dir = tempdir().expect("temp dir");
        let header = dir.path().join("demo.h");
        let output = dir.path().join("bindings.cl");
        std::fs::write(&header, "int demo_add(int a, int b);").expect("write header");

        let opts = ExternBindOptions {
            header: header.clone(),
            output: output.clone(),
            namespace: "Demo.Interop".into(),
            library: "demo".into(),
            binding: "eager".into(),
            convention: "system".into(),
            optional: true,
        };
        generate_bindings(&opts).expect("generate bindings");

        let contents = std::fs::read_to_string(&output).expect("bindings output");
        assert!(
            contents.contains("// <auto-generated by chic extern bind>"),
            "expected auto-generated banner: {contents}"
        );
        assert!(
            contents.contains("namespace Demo.Interop;"),
            "expected namespace declaration: {contents}"
        );
        assert!(
            contents.contains("library = \"demo\""),
            "expected library metadata: {contents}"
        );
        assert!(
            contents.contains("binding = \"eager\""),
            "expected binding metadata: {contents}"
        );
        assert!(
            contents.contains("optional = true"),
            "expected optional metadata: {contents}"
        );
        assert!(
            contents.contains("public static extern int demo_add(int a, int b);"),
            "expected sanitized signature: {contents}"
        );
    }
}
