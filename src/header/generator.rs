use crate::frontend::ast::{
    Attribute, BindingModifier, DocComment, FunctionDecl, Item, Module, NamespaceDecl, Parameter,
    Signature, StaticItemDecl, StaticMutability, UsingKind, Visibility,
};
use crate::primitives::{
    PrimitiveAttributeError, PrimitiveRegistrationError, PrimitiveRegistry,
    parse_primitive_attribute,
};
use std::collections::BTreeSet;
use std::fmt;

use super::types::{CType, map_type};

/// Configuration options for header generation.
#[derive(Debug, Clone, Default)]
pub struct HeaderOptions {
    pub include_guard: Option<String>,
}

/// Error produced while generating headers.
#[derive(Debug, Clone)]
pub struct HeaderError {
    message: String,
}

impl HeaderError {
    pub fn new(message: impl Into<String>) -> Self {
        Self {
            message: message.into(),
        }
    }
}

impl fmt::Display for HeaderError {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.write_str(&self.message)
    }
}

impl std::error::Error for HeaderError {}

/// Generate a C header for the public API exposed by the provided module.
pub fn generate_header(module: &Module, options: &HeaderOptions) -> Result<String, HeaderError> {
    let primitive_registry = build_primitive_registry(module)?;
    let mut functions = Vec::new();
    let mut scope = Vec::new();
    if let Some(ns) = &module.namespace {
        scope.extend(ns.split('.').map(str::to_string));
    }
    let mut includes = BTreeSet::new();
    collect_functions(
        &module.items,
        &mut scope,
        &mut functions,
        &mut includes,
        &primitive_registry,
    );
    functions.sort_by(|a, b| a.c_name.cmp(&b.c_name));
    let mut static_scope = Vec::new();
    if let Some(ns) = &module.namespace {
        static_scope.extend(ns.split('.').map(str::to_string));
    }
    let mut statics = Vec::new();
    collect_statics(
        &module.items,
        &mut static_scope,
        &mut statics,
        &mut includes,
        &primitive_registry,
    );
    statics.sort_by(|a, b| a.c_name.cmp(&b.c_name));

    let include_guard = options
        .include_guard
        .clone()
        .unwrap_or_else(|| derive_guard(module));

    let mut out = String::new();
    out.push_str("/* Autogenerated Chic header */\n");
    out.push_str(&format!("#ifndef {include_guard}\n"));
    out.push_str(&format!("#define {include_guard}\n\n"));
    out.push_str("#include <stdbool.h>\n");
    out.push_str("#include <stddef.h>\n");
    out.push_str("#include <stdint.h>\n");
    if !includes.is_empty() {
        out.push('\n');
        for header in &includes {
            let target = if header.starts_with('<') || header.starts_with('"') {
                header.clone()
            } else {
                format!("\"{header}\"")
            };
            out.push_str(&format!("#include {target}\n"));
        }
    }
    out.push_str("\n");
    out.push_str("typedef struct chic_string {\n");
    out.push_str("    uint8_t *ptr;\n");
    out.push_str("    size_t len;\n");
    out.push_str("    size_t cap;\n");
    out.push_str("    uint8_t inline_data[32];\n");
    out.push_str("} chic_string;\n");
    out.push_str("typedef struct chic_str {\n");
    out.push_str("    const uint8_t *ptr;\n");
    out.push_str("    size_t len;\n");
    out.push_str("} chic_str;\n\n");
    out.push_str("#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n");

    if functions.is_empty() && statics.is_empty() {
        out.push_str("// No public functions or extern globals were exported from this module.\n");
    } else {
        for (index, global) in statics.iter().enumerate() {
            if index > 0 {
                out.push('\n');
            }
            if let Some(doc) = &global.doc {
                write_doc_comment(&mut out, doc);
            }
            let thread_local = if global.thread_local {
                "_Thread_local "
            } else {
                ""
            };
            out.push_str(&format!(
                "extern {thread_local}{};\n",
                global.ctype.render_declarator(&global.c_name)
            ));
        }
        if !statics.is_empty() && !functions.is_empty() {
            out.push('\n');
        }
        for (index, function) in functions.iter().enumerate() {
            if index > 0 {
                out.push('\n');
            }
            if let Some(doc) = &function.doc {
                write_doc_comment(&mut out, doc);
            }
            let return_type = function.return_type.render_return();
            let params = if function.parameters.is_empty() {
                "void".to_string()
            } else {
                function
                    .parameters
                    .iter()
                    .map(|param| param.ctype.render_declarator(&param.name))
                    .collect::<Vec<_>>()
                    .join(", ")
            };
            out.push_str(&format!("{return_type} {}({params});\n", function.c_name));
        }
    }

    out.push_str("\n#ifdef __cplusplus\n}\n#endif\n\n");
    out.push_str(&format!("#endif /* {include_guard} */\n"));

    Ok(out)
}

struct FunctionSignatureEntry {
    c_name: String,
    return_type: CType,
    parameters: Vec<ParameterEntry>,
    doc: Option<DocComment>,
}

struct ParameterEntry {
    name: String,
    ctype: CType,
}

struct StaticEntry {
    c_name: String,
    ctype: CType,
    thread_local: bool,
    doc: Option<DocComment>,
}

fn build_primitive_registry(module: &Module) -> Result<PrimitiveRegistry, HeaderError> {
    let mut registry = PrimitiveRegistry::with_builtins();
    let mut scope = Vec::new();
    if let Some(ns) = &module.namespace {
        scope.extend(ns.split('.').map(str::to_string));
    }
    let mut errors = Vec::new();
    collect_primitives(&module.items, &mut scope, &mut registry, &mut errors);
    if errors.is_empty() {
        Ok(registry)
    } else {
        Err(HeaderError::new(errors.join("; ")))
    }
}

fn collect_primitives(
    items: &[Item],
    scope: &mut Vec<String>,
    registry: &mut PrimitiveRegistry,
    errors: &mut Vec<String>,
) {
    for item in items {
        match item {
            Item::Struct(decl) => {
                let qualified = qualify_type(scope, &decl.name);
                register_primitive_attributes(&qualified, &decl.attributes, registry, errors);
                if !decl.nested_types.is_empty() {
                    scope.push(decl.name.clone());
                    collect_primitives(&decl.nested_types, scope, registry, errors);
                    scope.pop();
                }
            }
            Item::Class(decl) => {
                let qualified = qualify_type(scope, &decl.name);
                register_primitive_attributes(&qualified, &decl.attributes, registry, errors);
                if !decl.nested_types.is_empty() {
                    scope.push(decl.name.clone());
                    collect_primitives(&decl.nested_types, scope, registry, errors);
                    scope.pop();
                }
            }
            Item::Namespace(ns) => {
                let pushed = extend_scope_with_namespace(scope, &ns.name);
                collect_primitives(&ns.items, scope, registry, errors);
                scope.truncate(scope.len().saturating_sub(pushed));
            }
            _ => {}
        }
    }
}

fn register_primitive_attributes(
    qualified_name: &str,
    attributes: &[Attribute],
    registry: &mut PrimitiveRegistry,
    errors: &mut Vec<String>,
) {
    for attr in attributes {
        if !attr.name.eq_ignore_ascii_case("primitive") {
            continue;
        }
        let (maybe_desc, parse_errors) = parse_primitive_attribute(attr, qualified_name);
        errors.extend(parse_errors.into_iter().map(|err| {
            format!(
                "`@primitive` on `{qualified_name}`: {}",
                format_primitive_attribute_error(err)
            )
        }));
        let Some(mut desc) = maybe_desc else {
            continue;
        };
        desc.std_wrapper_type
            .get_or_insert_with(|| qualified_name.to_string());
        desc.aliases.push(qualified_name.to_string());
        let dotted = qualified_name.replace("::", ".");
        if dotted != qualified_name {
            desc.aliases.push(dotted);
        }
        if desc.c_type.is_none() {
            errors.push(format!(
                "`@primitive` `{qualified_name}` is missing `c_type`, required for header generation"
            ));
        }
        if let Err(err) = registry.register(desc) {
            errors.push(format_registration_error(err, qualified_name));
        }
    }
}

fn format_primitive_attribute_error(err: PrimitiveAttributeError) -> String {
    err.message
}

fn format_registration_error(err: PrimitiveRegistrationError, context: &str) -> String {
    if let Some(conflict) = err.conflicting_span {
        format!(
            "failed to register primitive `{context}`: {} (conflicts at {conflict:?})",
            err.message
        )
    } else {
        format!("failed to register primitive `{context}`: {}", err.message)
    }
}

fn qualify_type(scope: &[String], name: &str) -> String {
    if scope.is_empty() {
        name.to_string()
    } else {
        format!("{}::{}", scope.join("::"), name)
    }
}

fn collect_functions(
    items: &[Item],
    scope: &mut Vec<String>,
    functions: &mut Vec<FunctionSignatureEntry>,
    includes: &mut BTreeSet<String>,
    primitives: &PrimitiveRegistry,
) {
    for item in items {
        match item {
            Item::Function(func) => {
                if matches!(func.visibility, Visibility::Public) && !func.is_async {
                    functions.push(build_function(scope, func, primitives));
                }
            }
            Item::Namespace(ns) => {
                enter_namespace(ns, scope, functions, includes, primitives);
            }
            Item::Import(using) => {
                if let UsingKind::CImport { header } = &using.kind {
                    includes.insert(header.clone());
                }
            }
            _ => {}
        }
    }
}

fn enter_namespace(
    namespace: &NamespaceDecl,
    scope: &mut Vec<String>,
    functions: &mut Vec<FunctionSignatureEntry>,
    includes: &mut BTreeSet<String>,
    primitives: &PrimitiveRegistry,
) {
    let pushed = extend_scope_with_namespace(scope, &namespace.name);
    collect_functions(&namespace.items, scope, functions, includes, primitives);
    scope.truncate(scope.len().saturating_sub(pushed));
}

fn collect_statics(
    items: &[Item],
    scope: &mut Vec<String>,
    statics: &mut Vec<StaticEntry>,
    includes: &mut BTreeSet<String>,
    primitives: &PrimitiveRegistry,
) {
    for item in items {
        match item {
            Item::Static(decl) => {
                if matches!(decl.visibility, Visibility::Public) && decl.declaration.is_extern {
                    statics.extend(build_static_entries(decl, primitives));
                }
            }
            Item::Namespace(ns) => {
                enter_namespace_statics(ns, scope, statics, includes, primitives);
            }
            Item::Import(using) => {
                if let UsingKind::CImport { header } = &using.kind {
                    includes.insert(header.clone());
                }
            }
            _ => {}
        }
    }
}

fn enter_namespace_statics(
    namespace: &NamespaceDecl,
    scope: &mut Vec<String>,
    statics: &mut Vec<StaticEntry>,
    includes: &mut BTreeSet<String>,
    primitives: &PrimitiveRegistry,
) {
    let pushed = extend_scope_with_namespace(scope, &namespace.name);
    collect_statics(&namespace.items, scope, statics, includes, primitives);
    scope.truncate(scope.len().saturating_sub(pushed));
}

fn extend_scope_with_namespace(scope: &mut Vec<String>, namespace: &str) -> usize {
    let parts: Vec<String> = namespace
        .split('.')
        .filter(|segment| !segment.is_empty())
        .map(str::to_string)
        .collect();
    let mut prefix = 0usize;
    while prefix < parts.len() && prefix < scope.len() && scope[prefix] == parts[prefix] {
        prefix += 1;
    }
    for part in parts.iter().skip(prefix) {
        scope.push(part.clone());
    }
    parts.len().saturating_sub(prefix)
}

fn build_function(
    scope: &[String],
    func: &FunctionDecl,
    primitives: &PrimitiveRegistry,
) -> FunctionSignatureEntry {
    let c_name = c_identifier(scope, &func.name);
    let return_type = map_type(primitives, &func.signature.return_type.name);
    let parameters = build_parameters(&func.signature, primitives);
    FunctionSignatureEntry {
        c_name,
        return_type,
        parameters,
        doc: func.doc.clone(),
    }
}

fn build_parameters(signature: &Signature, primitives: &PrimitiveRegistry) -> Vec<ParameterEntry> {
    signature
        .parameters
        .iter()
        .enumerate()
        .map(|(index, param)| ParameterEntry {
            name: parameter_name(param, index),
            ctype: map_parameter_type(param, primitives),
        })
        .collect()
}

fn build_static_entries(decl: &StaticItemDecl, primitives: &PrimitiveRegistry) -> Vec<StaticEntry> {
    let thread_local = has_threadlocal_attr(&decl.declaration.attributes);
    let mut ctype = map_type(primitives, &decl.declaration.ty.name);
    if matches!(decl.declaration.mutability, StaticMutability::Const) {
        ctype = ctype.with_const();
    }
    let doc = decl.declaration.doc.clone();
    let base_name = decl
        .declaration
        .extern_options
        .as_ref()
        .and_then(|opts| opts.alias.clone());
    decl.declaration
        .declarators
        .iter()
        .map(|declarator| {
            let c_name = base_name
                .clone()
                .unwrap_or_else(|| c_identifier(&[], &declarator.name));
            StaticEntry {
                c_name,
                ctype: ctype.clone(),
                thread_local,
                doc: doc.clone(),
            }
        })
        .collect()
}

fn parameter_name(param: &Parameter, index: usize) -> String {
    if param.name.trim().is_empty() {
        format!("arg{index}")
    } else {
        param.name.clone()
    }
}

fn map_parameter_type(param: &Parameter, primitives: &PrimitiveRegistry) -> CType {
    let mut ty = map_type(primitives, &param.ty.name);
    match param.binding {
        BindingModifier::Ref | BindingModifier::Out => {
            ty = ty.add_pointer();
        }
        BindingModifier::Value | BindingModifier::In => {}
    }
    ty
}

fn derive_guard(module: &Module) -> String {
    let mut guard = String::from("CHIC_");
    if let Some(ns) = &module.namespace {
        guard.push_str(&ns.replace(['.', ':'], "_").to_ascii_uppercase());
    } else {
        guard.push_str("MODULE");
    }
    guard.push_str("_H");
    guard
}

fn c_identifier(scope: &[String], name: &str) -> String {
    let mut parts = scope
        .iter()
        .filter(|part| !part.is_empty())
        .map(|part| part.replace(['.', ':'], "_"))
        .collect::<Vec<_>>();
    parts.push(name.replace(['.', ':'], "_"));
    parts.join("__")
}

fn normalized_attr_name(attribute: &Attribute) -> String {
    let mut name = attribute.name.to_ascii_lowercase();
    name.retain(|ch| ch != '_' && ch != '-');
    name
}

fn has_threadlocal_attr(attributes: &[Attribute]) -> bool {
    attributes
        .iter()
        .any(|attr| normalized_attr_name(attr) == "threadlocal")
}

fn write_doc_comment(out: &mut String, doc: &DocComment) {
    for line in &doc.lines {
        if line.trim().is_empty() {
            out.push_str("//\n");
        } else {
            out.push_str("// ");
            out.push_str(line);
            out.push('\n');
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::frontend::ast::{
        FunctionDecl, Item, MemberDispatch, Module, Parameter, Signature, TypeExpr, Visibility,
    };
    use crate::frontend::parser::UsingDirective;

    fn sample_module() -> Module {
        let mut module = Module::new(Some("Example.Core".into()));
        module.push_item(Item::Import(UsingDirective {
            doc: None,
            is_global: false,
            span: None,
            kind: UsingKind::CImport {
                header: "stdio.h".into(),
            },
        }));
        module.push_item(Item::Function(FunctionDecl {
            visibility: Visibility::Public,
            name: "Add".into(),
            name_span: None,
            signature: Signature {
                parameters: vec![
                    Parameter {
                        binding: BindingModifier::Value,
                        binding_nullable: false,
                        name: "left".into(),
                        name_span: None,
                        ty: TypeExpr::simple("int"),
                        attributes: Vec::new(),
                        di_inject: None,
                        default: None,
                        default_span: None,
                        lends: None,
                        is_extension_this: false,
                    },
                    Parameter {
                        binding: BindingModifier::Value,
                        binding_nullable: false,
                        name: "right".into(),
                        name_span: None,
                        ty: TypeExpr::simple("int"),
                        attributes: Vec::new(),
                        di_inject: None,
                        default: None,
                        default_span: None,
                        lends: None,
                        is_extension_this: false,
                    },
                ],
                return_type: TypeExpr::simple("int"),
                lends_to_return: None,
                variadic: false,
                throws: None,
            },
            body: None,
            is_async: false,
            is_constexpr: false,
            doc: None,
            modifiers: Vec::new(),
            is_unsafe: false,
            attributes: Vec::new(),
            is_extern: true,
            extern_abi: Some("C".into()),
            extern_options: None,
            link_name: None,
            link_library: None,
            operator: None,
            generics: None,
            vectorize_hint: None,
            dispatch: MemberDispatch::default(),
        }));
        module.rebuild_overloads();
        module
    }

    #[test]
    fn generates_simple_header() {
        let module = sample_module();
        let header = generate_header(&module, &HeaderOptions::default())
            .expect("header generation succeeds");
        assert!(header.contains("int32_t Example__Core__Add(int32_t left, int32_t right);"));
        assert!(header.contains("#include \"stdio.h\""));
        assert!(header.starts_with("/* Autogenerated Chic header */"));
    }

    #[test]
    fn skips_async_function() {
        let mut module = sample_module();
        module.push_item(Item::Function(FunctionDecl {
            visibility: Visibility::Public,
            name: "AsyncOp".into(),
            name_span: None,
            signature: Signature {
                parameters: Vec::new(),
                return_type: TypeExpr::simple("Task"),
                lends_to_return: None,
                variadic: false,
                throws: None,
            },
            body: None,
            is_async: true,
            is_constexpr: false,
            doc: None,
            modifiers: Vec::new(),
            is_unsafe: false,
            attributes: Vec::new(),
            is_extern: false,
            extern_abi: None,
            extern_options: None,
            link_name: None,
            link_library: None,
            operator: None,
            generics: None,
            vectorize_hint: None,
            dispatch: MemberDispatch::default(),
        }));
        let header = generate_header(&module, &HeaderOptions::default())
            .expect("header generation succeeds");
        assert!(!header.contains("AsyncOp"));
    }

    #[test]
    fn honours_include_guard_override() {
        let module = sample_module();
        let mut options = HeaderOptions::default();
        options.include_guard = Some("CUSTOM_GUARD".into());
        let header = generate_header(&module, &options).expect("header generation succeeds");
        assert!(header.contains("#ifndef CUSTOM_GUARD"));
        assert!(header.contains("#endif /* CUSTOM_GUARD */"));
    }
}
