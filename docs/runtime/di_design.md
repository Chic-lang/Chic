# Native Dependency Injection Design

This document sketches the bootstrap design for Chic's native dependency-injection (DI) system. The goal is to ship an idiomatic, allocation-friendly DI container that works on every Chic target (native + WASM) without introducing runtime reflection or dynamic typing. The design deliberately leans on compile-time metadata and MIR lowering so the eventual self-hosted compiler can enforce correctness statically.

## Goals

- Provide a container that resolves constructor, property, and method dependencies without relying on runtime reflection.
- Support opt-in lifetimes: `Transient`, `Scoped`, `Singleton`, and `ThreadLocal`.
- Keep registration and resolution fast by precomputing lookup tables during compilation wherever possible.
- Surface diagnostics when dependencies cannot be resolved, lifetime scopes conflict, or cycles are introduced.
- Generate zero-cost resolution paths for statically known graphs (constructor injection becomes straightforward function calls).
- Remain portable to WASM by avoiding threads in the core abstraction and pushing scheduling/thread semantics into optional executors.

## Container Semantics

### Registration Model

- Registrations are described via fluent APIs in `std.di.ContainerBuilder`:
  - `Register<TImplementation>().As<TService>()`
  - `RegisterFactory<TService>(fn(Container) -> TService)`
  - `RegisterInstance<TService>(TService instance)`
  - `RegisterOpenGeneric<TOpen>()` for `IRepository<T>` style bindings.
- Multiple registrations per service are stored in order of declaration. Resolution defaults to the last registration unless the service is marked `Enumerable`, in which case an aggregate is returned.
- Registrations capture lifetime (`Transient`, `Scoped`, `Singleton`, `ThreadLocal`), optional constructor choice, and metadata used by compile-time validation.

### Lifetime Scopes

- `Transient`: new instance for every request.
- `Scoped`: re-used within a `ContainerScope`; scopes can be created via `Container.CreateScope()` and cascaded.
- `Singleton`: single instance tied to the root container for the application lifetime.
- `ThreadLocal`: per-thread singleton; only valid on native targets with threading enabled. The bootstrap runtime exposes a guard to map to WASM (unsupported) and fall back with diagnostics.

### Resolution Path

- At runtime, resolution proceeds as follows:
  1. Lookup the service key in the container's registration table.
  2. Materialize the configured lifetime scope store (root/scope/thread).
  3. Invoke the factory generated at compile time.
- Factories are generated per registration, capturing constructor arguments and property injection metadata. Constructor cycles detect themselves via a resolution stack maintained by the container; the generator also emits cycle checks during validation.

## Injection Attributes

- `@inject` marks constructors, properties, or parameters that participate in DI.
- `@service` signals that the annotated class should be auto-registered with default semantics (constructor injection, transient lifetime).
- `@module` attaches to static classes that expose `Configure(ContainerBuilder)` methods for grouping registrations.
- Attributes carry optional metadata:
  - `@inject(lifetime: Scoped)` overrides the default lifetime.
  - `@inject(named: "Special")` selects a specific named registration.
  - `@inject(optional: true)` suppresses validation errors when the service is missing (caller receives `null`/`None`).

## Compile-Time Validation

The bootstrap compiler will extend MIR lowering and the type checker with a "binding manifest" pass:

1. During frontend processing, attribute metadata is recorded on constructors, properties, and parameters.
2. A new `DiRegistrationCollector` walks the MIR representation of modules that call into `std.di.ContainerBuilder`. It builds a graph describing service registrations, lifetimes, and dependencies.
3. The type checker consumes the graph to ensure:
   - Every required dependency resolves to exactly one registration (or an enumerable).
   - Lifetimes obey the standard rules (e.g., scoped service cannot depend on a transient that captures the scope, singleton cannot depend on scoped).
   - Injection targets match constructor signatures and property accessibility.
   - Open generics have corresponding implementations.
4. Failures produce diagnostics pointing back to the call site or attribute span.

The validated manifest is serialized into MIR metadata so backends can generate container code with concrete function pointers and layout information.

## Runtime Integration

- `chic_rt::di` ships the container primitives: registration tables, scope structures, thread-local storage hooks, and factory invocation helpers.
- Factories are represented as `extern "C"` thunks generated by the compiler. They receive a pointer to the container/scope and return the constructed instance with an associated drop glue pointer if needed.
- Scoped stores maintain a hash map keyed by service ID; WASM builds degrade gracefully by rejecting `ThreadLocal` lifetime during validation.
- Error reporting (missing registration at runtime) uses a structured `DiResolutionError` enumerating the failure reason, lifetime, and requested service.

## Sample Workflow

```chic
@service(lifetime: Singleton)
public class HttpClient { /* ... */ }

public interface IRepository<T>
{
    T Find(string id);
}

@service
public class UserRepository : IRepository<User>
{
    private readonly HttpClient _client;

    public UserRepository(@inject HttpClient client)
    {
        _client = client;
    }
}

public static class Services
{
    @module
    public static void Configure(ContainerBuilder builder)
    {
        builder.RegisterOpenGeneric(typeof(IRepository<>), typeof(UserRepository));
    }
}

var container = ContainerBuilder.CreateDefault()
    .AddModule(Services.Configure)
    .Build();

using var scope = container.CreateScope();
var repo = scope.Resolve<IRepository<User>>();
```

## Diagnostics Surface

- **Missing registration:** `error DI0001: no registration found for service 'IRepository<User>' required by 'UserService::UserService(UserRepository repository)'`.
- **Lifetime mismatch:** `error DI0002: scoped service 'Logger' cannot depend on transient 'FileWriter'`.
- **Cycle detection:** `error DI0003: dependency cycle detected: A -> B -> A`.
- **Unsupported lifetime:** `error DI0004: ThreadLocal lifetime is unavailable on WASM targets`.

Each diagnostic references both the registration site and the injection site to help users resolve conflicts quickly.

## Open Questions / Future Work

- Integration with async scopes for request-based lifetimes.
- Conditional registrations (environment-based, feature-based).
- Source generator integration once the self-hosted compiler supports incremental compilation.
- Tooling support for visualizing dependency graphs.

This design should be refined collaboratively before implementation, but it anchors the container semantics and validation approach expected by the runtime and tooling.
