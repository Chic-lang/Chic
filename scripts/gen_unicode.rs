use std::fs;
use std::io::Write;
use std::path::PathBuf;

struct EscapeEntry {
    marker: char,
    codepoint: char,
    description: &'static str,
}

fn main() -> Result<(), Box<dyn std::error::Error>> {
    let escapes = [
        EscapeEntry {
            marker: '\'',
            codepoint: '\'',
            description: "apostrophe",
        },
        EscapeEntry {
            marker: '"',
            codepoint: '"',
            description: "double_quote",
        },
        EscapeEntry {
            marker: '\\',
            codepoint: '\\',
            description: "backslash",
        },
        EscapeEntry {
            marker: '0',
            codepoint: '\0',
            description: "null",
        },
        EscapeEntry {
            marker: 'a',
            codepoint: '\u{0007}',
            description: "bell",
        },
        EscapeEntry {
            marker: 'b',
            codepoint: '\u{0008}',
            description: "backspace",
        },
        EscapeEntry {
            marker: 'f',
            codepoint: '\u{000C}',
            description: "form_feed",
        },
        EscapeEntry {
            marker: 'n',
            codepoint: '\n',
            description: "line_feed",
        },
        EscapeEntry {
            marker: 'r',
            codepoint: '\r',
            description: "carriage_return",
        },
        EscapeEntry {
            marker: 't',
            codepoint: '\t',
            description: "horizontal_tab",
        },
        EscapeEntry {
            marker: 'v',
            codepoint: '\u{000B}',
            description: "vertical_tab",
        },
    ];

    let out_dir = PathBuf::from("generated/unicode");
    fs::create_dir_all(&out_dir)?;
    let dest = out_dir.join("escapes.rs");

    let mut file = fs::File::create(&dest)?;
    let header = "// @generated by scripts/gen_unicode.rs\n// Do not edit this file manually.\n\n";
    file.write_all(header.as_bytes())?;

    file.write_all(b"pub const BASIC_ESCAPE_MAPPINGS: &[EscapeMapping] = &[\n")?;
    for entry in &escapes {
        writeln!(
            file,
            "    EscapeMapping {{ marker: {}, codepoint: {}, description: \"{}\" }},",
            char_literal(entry.marker),
            char_literal(entry.codepoint),
            entry.description
        )?;
    }
    file.write_all(b"];\n\n")?;

    let mut by_marker = vec!["None".to_string(); 128];
    for entry in &escapes {
        if entry.marker.is_ascii() {
            by_marker[entry.marker as usize] = format!("Some({})", char_literal(entry.codepoint));
        }
    }
    file.write_all(b"pub const BASIC_ESCAPE_BY_MARKER: [Option<char>; 128] = [\n")?;
    for value in &by_marker {
        writeln!(file, "    {value},")?;
    }
    file.write_all(b"];\n\n")?;

    let mut by_codepoint = vec!["None".to_string(); 128];
    for entry in &escapes {
        if entry.codepoint.is_ascii() {
            let index = entry.codepoint as usize;
            by_codepoint[index] = format!("Some({})", char_literal(entry.marker));
        }
    }
    file.write_all(b"pub const BASIC_ESCAPE_BY_CODEPOINT: [Option<char>; 128] = [\n")?;
    for value in &by_codepoint {
        writeln!(file, "    {value},")?;
    }
    file.write_all(b"];\n")?;

    Ok(())
}

fn char_literal(ch: char) -> String {
    let escaped = ch.escape_default().to_string();
    format!("'{}'", escaped)
}
