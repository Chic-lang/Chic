use serde::Deserialize;
use std::collections::BTreeMap;
use std::fs;
use std::path::PathBuf;

#[derive(Debug, Deserialize, Ord, PartialOrd, Eq, PartialEq, Clone)]
#[serde(rename_all = "lowercase")]
enum FixtureCategory {
    Tables,
    Memory,
    References,
}

#[derive(Debug, Deserialize)]
struct FixtureDescriptor {
    name: String,
    category: FixtureCategory,
    description: String,
}

fn workspace_root() -> PathBuf {
    PathBuf::from(env!("CARGO_MANIFEST_DIR")).join("..")
}

pub fn run() -> Result<(), Box<dyn std::error::Error>> {
    let root = workspace_root();
    let catalog_path = root.join("src/codegen/wasm/tests/common/type_fixtures/catalog.json");
    let catalog_raw = fs::read_to_string(&catalog_path)?;
    let fixtures: Vec<FixtureDescriptor> = serde_json::from_str(&catalog_raw)?;

    let mut grouped: BTreeMap<FixtureCategory, Vec<&FixtureDescriptor>> = BTreeMap::new();
    for fixture in &fixtures {
        grouped
            .entry(fixture.category.clone())
            .or_default()
            .push(fixture);
    }

    let mut output = String::new();
    output.push_str("# WASM type fixture index\n\n");
    output.push_str("Generated by `cargo xtask wasm-fixtures` from `catalog.json`.\n\n");

    for (category, entries) in grouped {
        output.push_str(&format!("## {:?}\n\n", category));
        for entry in entries {
            output.push_str(&format!(
                "- `{}`: {}\n",
                entry.name,
                entry.description.trim()
            ));
        }
        output.push('\n');
    }

    let output_path = root.join("src/codegen/wasm/tests/common/type_fixtures/INDEX.md");
    fs::write(output_path, output)?;
    println!("Updated fixture index from {catalog_path:?}");
    Ok(())
}
